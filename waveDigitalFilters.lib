import("stdfaust.lib");

//ABOUT THIS LIBRARY
/*
    This library is intended as a tool to help generating function DSP algorithims using Wave Digital Filters (WDF)
    The library includes both port elements with which to build symbolic WDF trees and the tools to turn those trees into DSP algorithims

    a simple use case of this library is shown at the bottom of the library. <- START HERE

    a description of how adaptors are structured is shown at the head of ONE PORT ELEMENTS
    
    a description of how the library builds the DSP algorithim from the user-given tree is shown at the head of //COMPILER/BUILDER

    Many of the more in depth comments within the library include jargon. I plan to create videos detailing the theory of WDF's
    For now I reccomend Kurt Werner's PhD, Virtual analog modeling of audio circuitry using wave digital filters, found here: 
    https://searchworks.stanford.edu/view/11891203    
    I have tried to maintain consistent syntax and notation to the thesis. This library currently includes the majority of the adaptors covered in chapter 1 and some from chapter 3. 
    
    I've included the definitions of some of the jargon/helpful context. 

*/

//SOME HELPFUL WDF TERMS
/*
    downward and upward going waves
    WDF's data/wave direction is often described in terms of downward and upward going waves described reletive to the tree structure. 
    Within the context of typical faust syntax, these can be understood as feedforward waves and feedback waves or forward-going and backward-going waves
    essentially downward-going = feedforward, upward-going = feedback. 

    port resistance
    each element within the tree structure passes a port resistance up to its parent, which the parent uses in calculations. 

*/

//HOW ADAPTORS ARE STRUCTURED
/*
    In order for adaptors to be interpretable by the compiler, they must be structured in a specific way. 
    Each adaptor is divided into three cases by their first parameter. This paramter, while accessible by the user, should only be set by the compiler/builder.
    All other parameters are value declarations (for components), inputs (for voltage or current ins), or parameter controls (for potentiometers/varible capicitors/varible inductors)

    (0, params) => downwardgoing(R1, ... Rn, a0, a1, ... an) --- first case --- function calculating downward going waves (b1, b2, ... bn)
        this function takes any number of port resistances, the downward going wave, and any number of upward going waves as inputs. 
        These values/waves are used to calculate the downward going waves coming from this adaptor

    (1, params) =>  upwardgoing(R1, ... Rn, a1, ... an) --- second case --- funciton calculating upward going wave (b0)
        this funciton takes any number of port resistances and any number of upward going waves as inputs
        these values/waves are used to calculate the upward going wave coming from this adaptor

    (2, params) => portresistance(R1, ... Rn) --- third case --- function calculating adaptor's port resitance (R0)
        this function takes any number of port resistances as inputs
        these values are used to calculate the upward going port resistance of the element

*/

//ONE PORT ELEMENTS
//resistors
resistor = 
case{
    (0, R) => !, 0; //a0 in, b0 out
    (1, R) => _; //b0 passthru
    (2, R) => R0 //port resistance. may replace this with dynamic allocation for port resistances. 
    with{
        R0 = R; 
    };
};

resistor_output = 
case{
    (0, R) => 0, _*.5; //a0 in, b0 out
    (1, R) => _, !; //b0 passthru
    (2, R) => R0 //port resistance. may replace this with dynamic allocation for port resistances. 
    with{
        R0 = R; 
    };
};

//capacitors made with BLT
capacitor =
case{
    (0, R) => _*1; 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
};

capacitor_output = 
case{
    (0, R) => b0
    with{
        b0(a1) =  a1*1, a1*.5 + (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
};

//inductors made with BLT
inductor =
case{
    (0, R) => _*(-1); 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
};

inductor_output = 
case{
    (0, R) => b0
    with{
        b0(a1) = a1*(-1), a1*.5 - (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
};


//resistive voltage sources
//adapted
resVoltage = 
case{
    (0, R, ein) => R^(1-p)*ein;
    (1, R, ein) => _; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}; 

resVoltage_output = 
case{
    (0, R, ein) => R^(1-p)*ein, _*.5 + R^(1-p)*ein*.5 ;
    (1, R, ein) => _, !; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}; 

//unadapted
u_resVoltage =
case {
    (0, R, ein) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R+R0) + ein*(2*R0^p)/(R + R0);
    };
    (1, R, ein) => !, !; 
    (2, R, ein) => 0; 

};

//resistive current source 

resCurrent =
case {
    (0, R, jin) => 2*R^(p)*jin;
    (1, R, jin) => _; 
    (2, R, jin) => R0
    with {
        R0 = R; 
    };
}; 

u_resCurrent =
case {
    (0, R, jin) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R + R0) + jin*(2*R*R0^p)/(R + R0);
    };
    (1, R, jin) => !, !; 
    (2, R, jin) => 0; 

};

//simple unadaptable elements. can only exist as root elements

//voltage source
u_Voltage = 
case{
    (0 , ein) => b0
    with{
        b0(R0, a0) = 2*R0^(p-1)*ein -a0;
    };
    (1, ein) => !, !; 
    (2, ein) => 0; 
};

//current source
u_Current = 
case{
    (0 , iin) => b0
    with{
        b0(R0, a0) = 2*R0^(p)*iin + a0;
    };
    (1, iin) => !, !; 
    (2, iin) => 0; 
};

//switch. 
//lambda = -1 for closed switch, lambda = 1 for open switch
u_Switch = 
case {
    (0, lambda) => b0
    with{
        b0(R0, a0) = a0*lambda; 
    };
    (1, lambda) => !, !; 
    (2, lambda) => 0; 
};

//NON-LINEAR ADAPTORS (1-PORT)


//2 PORT ADAPTORS

//parallel/echo/pass
u_parallel_2 = 
case{
    (0) => u_par
    with{ 
        u_par = si.bus(4) <: b1, b2;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) + a1*(2*R0^p*R1^(1-p)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) + a0*(2*R0^(1-p)*R1^p))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
};

parallel_2 = 
case{
    (0) => par_down
    with{
        par_down = b1; 
        b1(R1, a0, a1) = a0;  
    };
    (1) => par_up
    with{
        par_up = b0; 
        b0(R1, a1) = a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};

//series/inverter
u_series_2 = 
case{
    (0) => u_ser
    with{ 
        u_ser = si.bus(4) <: b1, b2;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) - a1*(2*R0^p*R1^(1-p)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) - a0*(2*R0^(1-p)*R1^p))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
};

series_2 = 
case{
    (0) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0;  
    };
    (1) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};

//adapted two ports with subsumed elements

//parallel + current source
parallel_current = 
case{
    (0, jin) => par_current_down
    with{
        par_current_down = b1; 
        b1(R1, a0, a1) = a0 + R1^p*jin;  
    };
    (1, jin) => par_current_up
    with{
        par_current_up = b0; 
        b0(R1, a1) = a1 + R1^p*jin; 
    };
    (2, jin) => R0
    with{
        R0(R1) = R1; 
    };
};

//series + voltage source
series_voltage = 
case{
    (0, vin) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0 - R1^(p-1)*vin;  
    };
    (1, vin) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1 - R1^(p-1)*vin; 
    };
    (2, vin) => R0
    with{
        R0(R1) = R1; 
    };
};

//3 PORT ADAPTORS

//paralell 3 port
parallel= 
case{
    (0) => par_down
    with{
        par_down = si.bus(5) <: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 +  a1 * -R1/(R1 + R2) + a2 * R1/(R1 + R2);
        b2(R1, R2, a0, a1, a2) = a0 +  a1 * R2/(R1 + R2) + a2 * -R2/(R1 + R2);
    };
    (1) => par_up
    with{
        par_up = b0;
        b0(R1, R2, a1, a2) = a1 * R2/(R1 + R2) + a2 * R1/(R1 + R2);
    };
    (2) => R0
    with{
        R0(R1, R2) = 1/(1/R1+1/R2); 
    };

};

//series 3 port
series= 
case{

    (0) => ser_down
    with{
        ser_down = si.bus(5)<: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 * -R1/(R1+R2) + a1 * R2/(R1+R2) +  a2 *-R1/(R1+R2);
        b2(R1, R2, a0, a1, a2) = a0 * -R2/(R1+R2) + a1 * -R2/(R1+R2) + a2 * R1/(R1+R2);
    };
    (1) => ser_up
    with{
        ser_up = b0;
        b0(R1, R2, a1, a2) = -a1 - a2;
    };
    (2) => R0
    with{
        R0(R1, R2) = R1 + R2; 
    };
};



//constant declrations for library. don't alter these (for now)
p = 1; //declare voltage waves. 
t = 1/ma.SR; //sampling rate reference for reactive elements


//constructor private functions

//substitute for si.bus which can accept an argument of 0
addins = 
case{
    (0) => 0 : !; 
    (x) => si.bus(x);
};

//downtree constructor 
builddown(A : As) = ((upPortRes, addins(inputs(A(0)) - outputs(upPortRes))) :  A(0)) , addins(inputs(pardown(As)) - outputs(A(0))) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross(0, 0, 0, 0, 0, s_mtx(As))) : pardown(As)
with{
    
    pardown = 
    case{
        ((Ax, Axx)) => builddown(Ax), pardown(Axx);
        (Ax) => builddown(Ax);
    };
    
    s_mtx = 
    case{
        ((Ax, Axx)) => inputs(builddown(Ax)), s_mtx(Axx);
        (Ax) => inputs(builddown(Ax));
    };

    upPortRes = parres(As);

    gencross = 
    case{
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        (0, 0, 0, 0, 0, 0) => 0 : !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (fcount, msum);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum, msum-count); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => ((count+out), out), gencross(out+1, next, count, fcount, msum, xs); //output is not a special output

    };

    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));
}; 

builddown(A) = A(0); 

//uptree constructor
buildup(A : As) = upPortRes, (parup(As) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross_up(0, 0, 0, 0, 0, s_mtx(As))) : split(s_mtx(As))) : A(1), addins(outputs(split(s_mtx(As))) + outputs(upPortRes) - inputs(A(1))) 
with{

    parup =  //<: crossover(out_list(Ap)) : split(out_list(Ap))
    case{
        ((Ax, Axx)) => buildup(Ax), parup(Axx);
        (Ax) => buildup(Ax);
    };

    //create our dimension matrix
    s_mtx = 
    case{
        ((Ax, Axx)) => outputs(buildup(Ax)), s_mtx(Axx);
        (Ax) => outputs(buildup(Ax));
    };
    
    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));
    //split signals based on a dimension matrix
    split(inl) = (si.bus(n) <: si.bus(n), si.bus(n)), (addins(s-n))
    with{
        n = ba.count(inl);
        s = inl :> _; 
    };

    gencross_up = 
    case{
        //corner case which must be coded manually
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        //user access function
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross_up(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        //more corner cases
        (0, 0, 0, 0, 0, 0) => 0: !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (msum, fcount);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum-count, msum); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => (out, (count+out)), gencross_up(out+1, next, count, fcount, msum, xs); //output is not a special output

    };
    //crossover.  feed a matrix with the dimensions of the buss. 
    crossover(inl) =  par(i, ba.count(inl), ba.selector((ba.subseq(inl, 0, i):> _)*ma.signum(i), (inl:> _))), par(i, ba.count(inl), (!, addins(ba.take(i+1, inl) - 1)));

    upPortRes = parres(As);
};

buildup(A) = A(1);

//resistance contructor. 
//maybe change this to a dynamic programming method as current method involves calculating port resistance for each element many times. 
getres(A: As) = parres(As) : A(2);
getres(A) = A(2); 

parres((Ap1, Ap2)) = getres(Ap1) , parres(Ap2);
parres(Ap) = getres(Ap);


//TODO
//add input and output constructor. currently just performed manually. 
//this will likely include adding additional param options to adaptors. 
