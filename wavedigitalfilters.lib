//#################################### wavedigitalfilters.lib ####################################################################
// A library of basic adaptors and methods to help contstruct Wave Digital Filter models in Faust. Its official prefix is `wd`.
//################################################################################################################################

/************************************************************************
************************************************************************
FAUST library file

NOTE ABOUT LICENSES:
Each function in this library has its own license. Licenses are declared
before each function. Corresponding license terms can be found at the 
bottom of this file or in the Faust libraries documentation.

The Wave Digital Filter Library is organized into the following sections

*Simple One Port Adaptors
*Simple Two Port Adaptors
*Simple Three Port Adaptors
*One Port Non-Linear Adaptors
*Model-Building Functions

PLANNED ADDITIONS
*R-type Adaptors
*Multiport Non-Linear Adaptors


ABOUT THIS LIBRARY

This library is intended as a tool to help generating function DSP algorithims using Wave Digital Filters (WDF)
The library includes both port elements with which to build symbolic WDF trees and the tools to turn those trees into DSP algorithims

implementation examples can be found at https://github.com/droosenb/faust-wdf-library

a description of how adaptors are structured is shown at the head of *Simple One Port Adaptors

a description of how the library builds the DSP algorithim from the user-given tree is shown at the head of *Model-Building Functions

Many of the more in depth comments within the library include jargon. I plan to create videos detailing the theory of WDF's
For now I reccomend Kurt Werner's PhD, Virtual analog modeling of audio circuitry using wave digital filters, found here: 
https://searchworks.stanford.edu/view/11891203    
I have tried to maintain consistent syntax and notation to the thesis. 
This library currently includes the majority of the adaptors covered in chapter 1 and some from chapter 3. 

************************************************************************
************************************************************************/

ba = library("basics.lib");
ro = library("routes.lib");
ma = library("maths.lib");
si = library("signals.lib");

declare name "Faust Wave Digital Filter Library";
declare version "0.1";



//HOW ADAPTORS ARE STRUCTURED
/*
    In order for adaptors to be interpretable by the compiler, they must be structured in a specific way. 
    Each adaptor is divided into three cases by their first parameter. This paramter, while accessible by the user, should only be set by the compiler/builder.
    All other parameters are value declarations (for components), inputs (for voltage or current ins), or parameter controls (for potentiometers/varible capicitors/varible inductors)
    
    --- first case ---
    (0, params) => downwardgoing(R1, ... Rn, a0, a1, ... an) -- function calculating downward going waves (b1, b2, ... bn)
        this function takes any number of port resistances, the downward going wave, and any number of upward going waves as inputs. 
        These values/waves are used to calculate the downward going waves coming from this adaptor

    --- second case ---
    (1, params) =>  upwardgoing(R1, ... Rn, a1, ... an) -- funciton calculating upward going wave (b0)
        this funciton takes any number of port resistances and any number of upward going waves as inputs
        these values/waves are used to calculate the upward going wave coming from this adaptor

    --- third case --- 
    (2, params) => portresistance(R1, ... Rn) -- function calculating adaptor's port resitance (R0)
        this function takes any number of port resistances as inputs
        these values are used to calculate the upward going port resistance of the element


    --Unadapted Adaptors--
    Unadapted adaptor's names will always begin "u_"
    An unadapted adaptor MUST be used as the root of the WDF tree structure.
    Unadapted adaptors can ONLY be used as a root of the WDF tree structure. 
    While unadapted adaptors contain all three cases, the second and thrid are purely structural. 
    Only the first case should contain computational information. 

*/

//=============================Agebraic One Port Adaptors=================================
//========================================================================================

//NOTES
//one 

//----------------------`(wd.)resistor`--------------------------
// Resistor
// A basic adaptor implementing a resistor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
//
// #### Usage
//
// ```
// r1(i) = resistor(i, R);
// buildtree( A : r1 );
//
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedence of the resistor being modeled in Ohms. 
//
// Note:
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.1
//----------------------------------------------------------
declare resistor author "Dirk Roosenburg";
declare resistor copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resistor license "MIT-style STK-4.3 license";
resistor = 
case{
    (0, R) => !, 0; 
    (1, R) => _; 
    (2, R) => R0 
    with{
        R0 = R; 
    };
};


//----------------------`(wd.)resistor_output`--------------------------
// Resistor + voltage Out
// A basic adaptor implementing a resistor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// The resistor will also pass the voltage across itself as an output of the model
//
// #### Usage
//
// ```
// rout(i) = resistor_output(i, R);
// buildtree( A : rout ) : _;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedence of the resistor being modeled in Ohms. 
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.1
//----------------------------------------------------------
declare resistor_output author "Dirk Roosenburg";
declare resistor_output copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resistor_output license "MIT-style STK-4.3 license";
resistor_output = 
case{
    (0, R) => 0, _*.5; 
    (1, R) => _, !; 
    (2, R) => R0 
    with{
        R0 = R; 
    };
};


//----------------------`(wd.)resistor_output_current`--------------------------
// Resistor + current Out
// A basic adaptor implementing a resistor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// The resistor will also pass the current through itself as an output of the model
//
// #### Usage
//
// ```
// rout(i) = resistor_output_current(i, R);
// buildtree( A : rout ) : _;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedence of the resistor being modeled in Ohms. 
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.1
//----------------------------------------------------------
declare resistor_output_current author "Dirk Roosenburg";
declare resistor_output_current copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resistor_output_current license "MIT-style STK-4.3 license";
resistor_output_current = 
case{
    (0, R) => 0, _*.5/R; 
    (1, R) => _, !; 
    (2, R) => R0 
    with{
        R0 = R; 
    };
};


//----------------------`(wd.)u_voltage`--------------------------
// Ideal Voltage Source (Unadapted)
// An adaptor implementing an ideal voltage source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = u_Voltage(i, ein);
// buildtree( v1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.2
//----------------------------------------------------------
declare u_voltage author "Dirk Roosenburg";
declare u_voltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_voltage license "MIT-style STK-4.3 license";
u_voltage = 
case{
    (0 , ein) => b0
    with{
        b0(R0, a0) = 2*R0^(p-1)*ein -a0;
    };
    (1, ein) => !, !; 
    (2, ein) => 0; 
};


//----------------------`(wd.)u_current`--------------------------
// Resistive Current Source (Unadapted)
// An unadapted adaptor implementing an ideal current source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = u_current(i, jin);
// buildtree( i1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.3
//----------------------------------------------------------
declare u_current author "Dirk Roosenburg";
declare u_current copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_current license "MIT-style STK-4.3 license";
u_current = 
case{
    (0 , jin) => b0
    with{
        b0(R0, a0) = 2*R0^(p)*jin + a0;
    };
    (1, jin) => !, !; 
    (2, jin) => 0; 
};

//----------------------`(wd.)resVoltage`--------------------------
// Resistive Voltage Source
// An adaptor implementing a resitive voltage source within Wave Digital Filter tree structures.
//
// It should be used as a leaf/terminating element of the tree structure
// It is comprised of an ideal voltage source in series with a resistor
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = resVoltage(i, R, ein);
// buildtree( A : v1 );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `ein` : Voltage/Potential of the ideal voltage source in Volts
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.4
//----------------------------------------------------------
declare resVoltage author "Dirk Roosenburg";
declare resVoltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resVoltage license "MIT-style STK-4.3 license";
resVoltage = 
case{
    (0, R, ein) => R^(1-p)*ein;
    (1, R, ein) => _; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}; 

//----------------------`(wd.)resVoltage_output`--------------------------
// Resistive Voltage Source + voltage output
// An adaptor implementing a resitive voltage source within Wave Digital Filter tree structures.
//
// It should be used as a leaf/terminating element of the tree structure
// It is comprised of an ideal voltage source in series with a resistor
// Can be used for either DC (constant) or AC (signal) voltage sources.
// The resistive voltage source will also pass the voltage across it as an output of the model
//
// #### Usage
//
// ```
// vout(i) = resVoltage_output(i, R, ein);
// buildtree( A : vout ) : _;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.4
//----------------------------------------------------------
declare resVoltage_output author "Dirk Roosenburg";
declare resVoltage_output copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resVoltage_output license "MIT-style STK-4.3 license";
resVoltage_output = 
case{
    (0, R, ein) => R^(1-p)*ein, _*.5 + R^(1-p)*ein*.5 ;
    (1, R, ein) => _, !; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}; 

//----------------------`(wd.)u_resVoltage`--------------------------
// Resistive Voltage Source (Unadapted)
// An unadapted adaptor implementing a resitive voltage source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// It is comprised of an ideal voltage source in series with a resistor
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = u_resVoltage(i, R, ein);
// buildtree( v1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.4
//----------------------------------------------------------
declare u_resVoltage author "Dirk Roosenburg";
declare u_resVoltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_resVoltage license "MIT-style STK-4.3 license";
u_resVoltage =
case {
    (0, R, ein) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R+R0) + ein*(2*R0^p)/(R + R0);
    };
    (1, R, ein) => !, !; 
    (2, R, ein) => 0; 

};


//----------------------`(wd.)resCurrent`--------------------------
// Resistive Current Source
// An adaptor implementing a resitive current source within Wave Digital Filter tree structures.
//
// It should be used as a leaf/terminating element of the tree structure
// It is comprised of an ideal current source in parallel with a resistor
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = resCurrent(i, R, jin);
// buildtree( A : i1 );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the parallel resistor in Ohms
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.5
//----------------------------------------------------------
declare resCurrent author "Dirk Roosenburg";
declare resCurrent copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resCurrent license "MIT-style STK-4.3 license";
resCurrent =
case {
    (0, R, jin) => !, 2*R^(p)*jin;
    (1, R, jin) => _; 
    (2, R, jin) => R0
    with {
        R0 = R; 
    };
}; 

//----------------------`(wd.)u_resCurrent`--------------------------
// Resistive Current Source (Uadapted)
// An unadapted adaptor implementing a resitive current source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// It is comprised of an ideal current source in parallel with a resistor
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = u_resCurrent(i, R, jin);
// buildtree( i1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.5
//----------------------------------------------------------
declare u_resCurrent author "Dirk Roosenburg";
declare u_resCurrent copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_resCurrent license "MIT-style STK-4.3 license";
u_resCurrent =
case {
    (0, R, jin) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R + R0) + jin*(2*R*R0^p)/(R + R0);
    };
    (1, R, jin) => !, !; 
    (2, R, jin) => 0; 

};

//TODO
//add short circuit (1.2.6), add open circuit (1.2.7)

//----------------------`(wd.)u_switch`--------------------------
// Ideal Switch (Unadapted)
// An unadapted adaptor implementing an ideal switch for Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
//
// #### Usage
//
// ```
// s1(i) = u_resCurrent(i, lambda);
// buildtree( s1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `lambda` : switch state control. -1 for closed switch, 1 for open switch.
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.8
//----------------------------------------------------------
declare u_Switch author "Dirk Roosenburg";
declare u_Switch copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_Switch license "MIT-style STK-4.3 license";
u_Switch = 
case {
    (0, lambda) => b0
    with{
        b0(R0, a0) = a0*lambda; 
    };
    (1, lambda) => !, !; 
    (2, lambda) => 0; 
};

//=============================Reactive One Port Adaptors=================================
//========================================================================================
//TODO - add mobius transform or alpha transform versions

//----------------------`(wd.)capacitor`--------------------------
// Capacitor
// A basic adaptor implementing a capacitor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// This capacitor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// c1(i) = capacitor(i, R);
// buildtree( A : c1 ) : _;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Capacitance/Impedence of the capacitor being modeled in Farads. 
//
// Note:
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.1
//----------------------------------------------------------
declare capacitor author "Dirk Roosenburg";
declare capacitor copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare capacitor license "MIT-style STK-4.3 license";
capacitor =
case{
    (0, R) => _*1; 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
};

//----------------------`(wd.)capacitor_output`--------------------------
// Capacitor + voltage out
// A basic adaptor implementing a capacitor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// The capacitor will also pass the voltage across itself as an output of the model
// This capacitor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// cout(i) = capacitor_output(i, R);
// buildtree( A : cout ) : _;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Capacitance/Impedence of the capacitor being modeled in Farads. 
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.1
//----------------------------------------------------------
declare capacitor_output author "Dirk Roosenburg";
declare capacitor_output copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare capacitor_output license "MIT-style STK-4.3 license";
capacitor_output = 
case{
    (0, R) => b0
    with{
        b0(a1) =  a1*1, a1*.5 + (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
};

//----------------------`(wd.)inductor`--------------------------
// Inductor
// A basic adaptor implementing an inductor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// This inductor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// l1(i) = inductor(i, R);
// buildtree( A : l1 );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Inductance/Impedence of the inductor being modeled in Henries. 
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.2
//----------------------------------------------------------
declare inductor author "Dirk Roosenburg";
declare inductor copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare inductor license "MIT-style STK-4.3 license";
inductor =
case{
    (0, R) => _*(-1); 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
};

//----------------------`(wd.)inductor_output`--------------------------
// Inductor + Voltage out
// A basic adaptor implementing an inductor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// The inductor will also pass the voltage across itself as an output of the model
// This inductor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// lout(i) = inductor_output(i, R);
// buildtree( A : lout ) : _;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Inductance/Impedence of the inductor being modeled in Henries.
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.2
//----------------------------------------------------------
declare inductor_output author "Dirk Roosenburg";
declare inductor_output copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare inductor_output license "MIT-style STK-4.3 license";
inductor_output = 
case{
    (0, R) => b0
    with{
        b0(a1) = a1*(-1), a1*.5 - (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
};

//===============================Nonlinear One Port Adaptors==============================
//========================================================================================

//----------------------`(wd.)u_idealDiode`--------------------------
// Ideal Diode (Unadapted)
// An unadapted adaptor implementing an ideal diode for Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
//
// #### Usage
//
// ```
// buildtree( u_idealDiode : B );
// ```
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 3.2.3
//----------------------------------------------------------
declare u_idealDiode author "Dirk Roosenburg";
declare u_idealDiode copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_idealDiode license "MIT-style STK-4.3 license";
u_idealDiode =
case{
    (0) => b1
    with{
        b1(R1, a0) = a0 : abs : *(-1);
    };
    (1) => !, !; 
    (2) => 0; 
};

//----------------------`(wd.)u_chua`--------------------------
// Chua Diode (Unadapted)
// An adaptor implementing the chua diode / non-linear resistor within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
//
// #### Usage
//
// ```
// chua1(i) = u_chua(i, G1, G2, V0);
// buildtree( chua1 : B ) ;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `G1` : resistance parameter 1 of the chua diode
// * `G2` : resistance parameter 2 of the chua diode
// * `V0` : voltage parameter of the chua diode
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
// #### Reference
// Meerkotter and Scholz, "Digital Simulation of Nonlinear Circuits by Wave Digital Filter Principles"
//----------------------------------------------------------
declare u_chua author "Dirk Roosenburg";
declare u_chua copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_chua license "MIT-style STK-4.3 license";
u_chua = 
case{
    (0, G1, G2, V0) => b1
    with{
        b1(R1, a0) = g_1*a0 + 1/2*(g_2 - g_1)*(((a0 + a_0) : abs) - ((a0 - a_0): abs))
        with{
            g_1 = (1-G1*R1)/(1+G1*R1);
            g_2 = (1-G2*R1)/(1+G2*R1);
            a_0 = V0*(1+G2*R1);
        };
    };
    (1, G1, G2, V0) => !, !; 
    (2, G1, G2, V0) => 0; 
};


//----------------------`(wd.)lambert`--------------------------
// An implementation of the lambert function
// It uses Halley's method of iteration to aproximate the output
// Indluded in the wdf library for use in non-linear diode models
// adapted from  K M Brigg's c++ lambert function approximator
//
// #### Usage
//
// ```
// lambert(n, itr) : _;
// ```
//
// Where:
// * `n`: value at which the lambert function will be evaluated
// * `itr`: number of iterations before output
//
//----------------------------------------------------------
declare lambert author "Dirk Roosenburg";
declare lambert copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare lambert license "MIT-style STK-4.3 license";
lambert(z, itr) = ba.if((z<(-em1+.0001)), less_approx, greater_approx)
with{
    less_approx = -1.0
     +2.331643981597124203363536062168*r
     -1.812187885639363490240191647568*q
     +1.936631114492359755363277457668*r*q
     -2.353551201881614516821543561516*q2
    with{
        q = z+em1;
        r = sqrt(q);
        q2 = q*q; 
    };
    eps=4.0e-16; 
    em1=0.3678794411714423215955237701614608;
    greater_approx = z : init : seq(i, itr, approx)
    with{
        init(w) = ba.if((z<1), init1, init2)
        with{
            init1 = -1.0+p*(1.0+p*(-0.333333333333333333333+p*0.152777777777777777777777))
            with{
                p=sqrt(2.0*(2.7182818284590452353602874713526625*z+1.0));
            };
            init2 = log(abs(z));
        };
        approx(w) = w-t
        with{
            e=exp(w);
            t=(w*e-z)/(e*p-.5*(p+1.0)*(w*e-z)/p);
            p=w+1; 
        };
    };
};


//----------------------`(wd.)u_diodePair`--------------------------
// A pair of diodes facing in opposite directions
// An unadapted adaptor implementing two antiparallel diodes for Wave Digital Filter tree structures.
// The behavior is approximated using Schottkey's ideal diode law
//
// #### Usage
//
// ```
// d1 = u_diodePair(i, Is, Vt);
// buildtree( d1 : B );
// ```
//
// Where:
// 
// * `i`: index used by model-building functions. Should never be user declared.
// * `Is` : saturation current of the diodes
// * `Vt` : thermal resistances of the diodes
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
// #### Reference
// K. Werner et al. "An Improved and Generalized Diode Clipper Model for Wave Digital Filters"
//----------------------------------------------------------
declare u_diodePair author "Dirk Roosenburg";
declare u_diodePair copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_diodePair license "MIT-style STK-4.3 license";
u_diodePair = 
case{
    (0, Is, Vt) => b1
    with{
        b1(R1, a1) = a1 + 2*R1*Is - 2*Vt*lambert((R1*Is/Vt*(((a1+R1*Is)/Vt), 3) : exp));
    };
    (1, Is, Vt) => !, !; 
    (2, Is, Vt) => 0; 
};


//----------------------`(wd.)u_diodeSingle`--------------------------
// A single diode
// An unadapted adaptor implementing a single diode for Wave Digital Filter tree structures.
// The behavior is approximated using Schottkey's ideal diode law
//
// #### Usage
//
// ```
// d1 = u_diodeSingle(i, Is, Vt);
// buildtree( d1 : B );
// ```
//
// Where:
// 
// * `i`: index used by model-building functions. Should never be user declared.
// * `Is` : saturation current of the diodes
// * `Vt` : thermal resistances of the diodes
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
// #### Reference
// K. Werner et al. "An Improved and Generalized Diode Clipper Model for Wave Digital Filters"
//----------------------------------------------------------
declare u_diodeSingle author "Dirk Roosenburg";
declare u_diodeSingle copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_diodeSingle license "MIT-style STK-4.3 license";
u_diodeSingle = 
case{
    (0, Is, Vt) => b1
    with{
        b1(R1, a1) = ma.signum(a1)*( (a1 : abs) + 2*R1*Is - 2*Vt*(lambert((R1*Is/Vt*((((a1 : abs)+R1*Is)/Vt) : exp)),3) + lambert((-R1*Is/Vt*(((-1*(a1 : abs)+R1*Is)/Vt) : exp)),3)));
    };
    (1, Is, Vt) => !, !; 
    (2, Is, Vt) => 0; 
};

//----------------------`(wd.)u_diodeAntiparallel`--------------------------
// A set of antiparallel diodes with M diodes facing forwards and N diodes facing backwards
// An unadapted adaptor implementing antiparallel diodes for Wave Digital Filter tree structures.
// The behavior is approximated using Schottkey's ideal diode law
//
// #### Usage
//
// ```
// d1 = u_diodeAntiparallel(i, Is, Vt);
// buildtree( d1 : B );
// ```
//
// Where:
// 
// * `i`: index used by model-building functions. Should never be user declared.
// * `Is` : saturation current of the diodes
// * `Vt` : thermal resistances of the diodes
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
// #### Reference
// K. Werner et al. "An Improved and Generalized Diode Clipper Model for Wave Digital Filters"
//----------------------------------------------------------
declare u_diodeAntiparallel author "Dirk Roosenburg";
declare u_diodeAntiparallel copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_diodeAntiparallel license "MIT-style STK-4.3 license";
u_diodeAntiparallel =
case{
    (0, Is, Vt, M, N) => b1
    with{
        b1(R1, a1) = a1 - 2*lam*Vt*(mu0* lambert(((R1*Is)/(mu0*Vt) * exp((lam*a1)/(mu0*Vt))), 3) + 
                                    mu1* lambert(((-R1*Is)/(mu1*Vt) * exp((-lam*a1)/(mu1*Vt))), 3))
        with{
            lam = ma.signum(a1); 
            mu0 = ba.if((a1 < 0), N, M);
            mu1 = ba.if((a1 > 0), M, N);
        };
    };
    (1, Is, Vt, M, N) => !, !; 
    (2, Is, Vt, M, N) => 0; 
};


//=============================Two Port Adaptors==========================================
//========================================================================================


//----------------------`(wd.)u_parallel_2`--------------------------
// 2-port parallel adaptor (Unadapted)
// An unadapted adaptor implementing a 2-port parallel connection between adaptors for Wave Digital Filter tree structures.
// Elements connected to this adaptor will behave as if connected in parallel in circuit
//
// #### Usage
//
// ```
// buildtree( u_parallel_2 : (A, B) );
// ```
//
// Note: 
// Only usable as the root of a tree
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare u_parallel_2 author "Dirk Roosenburg";
declare u_parallel_2 copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_parallel_2 license "MIT-style STK-4.3 license";
u_parallel_2 = 
case{
    (0) => u_par
    with{ 
        u_par = si.bus(4) <: b1, b2;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) + a1*(2*R0^p*R1^(1-p)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) + a0*(2*R0^(1-p)*R1^p))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
};


//----------------------`(wd.)parallel_2`--------------------------
// 2-port parallel adaptor
// An adaptor implementing a 2-port parallel connection between adaptors for Wave Digital Filter tree structures.
// Elements connected to this adaptor will behave as if connected in parallel in circuit
//
// #### Usage
//
// ```
// buildtree( A : parallel_2 : B );
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the tree structure with one previous and one forward adaptor
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare parallel_2 author "Dirk Roosenburg";
declare parallel_2 copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parallel_2 license "MIT-style STK-4.3 license";
parallel_2 = 
case{
    (0) => par_down
    with{
        par_down = b1; 
        b1(R1, a0, a1) = a0;  
    };
    (1) => par_up
    with{
        par_up = b0; 
        b0(R1, a1) = a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};

//----------------------`(wd.)u_series_2`--------------------------
// 2-port series adaptor (Unadapted)
// An unadapted adaptor implementing a 2-port series connection between adaptors for Wave Digital Filter tree structures.
// Elements connected to this adaptor will behave as if connected in series in circuit
//
// #### Usage
//
// ```
// buildtree( u_series_2 : (A, B) );
// ```
//
// Note: 
// Only usable as the root of a tree
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare u_series_2 author "Dirk Roosenburg";
declare u_series_2 copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_series_2 license "MIT-style STK-4.3 license";
u_series_2 = 
case{
    (0) => u_ser
    with{ 
        u_ser = si.bus(4) <: b1, b2;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) - a1*(2*R0^p*R1^(1-p)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) - a0*(2*R0^(1-p)*R1^p))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
};


//----------------------`(wd.)series_2`--------------------------
// 2-port series adaptor
// An adaptor implementing a 2-port series connection between adaptors for Wave Digital Filter tree structures.
// Elements connected to this adaptor will behave as if connected in series in circuit
//
// #### Usage
//
// ```
// buildtree( A : series_2 : B );
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the tree structure with one previous and one forward adaptor
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare series_2 author "Dirk Roosenburg";
declare series_2 copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare series_2 license "MIT-style STK-4.3 license";
series_2 = 
case{
    (0) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0;  
    };
    (1) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};


//----------------------`(wd.)parallel_current`--------------------------
// 2-port parallel adaptor + ideal current source
// An adaptor implementing a 2-port series connection and internal idealized current source between adaptors for Wave Digital Filter tree structures.
// This adaptor connects the two connected elements and an additional ideal current source in parallel
//
// #### Usage
//
// ```
// i1 = parallel_current(i, jin);
// buildtree(A : i1 : B);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `jin` :  Current through the ideal current source in Amps
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// It should be used within a tree structure with one previous and one forward adaptor
// Correct implementation is shown above.
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.2
//----------------------------------------------------------
declare parallel_current author "Dirk Roosenburg";
declare parallel_current copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parallel_current license "MIT-style STK-4.3 license";
parallel_current = 
case{
    (0, jin) => par_current_down
    with{
        par_current_down = b1; 
        b1(R1, a0, a1) = a0 + R1^p*jin;  
    };
    (1, jin) => par_current_up
    with{
        par_current_up = b0; 
        b0(R1, a1) = a1 + R1^p*jin; 
    };
    (2, jin) => R0
    with{
        R0(R1) = R1; 
    };
};


//----------------------`(wd.)series_voltage`--------------------------
// 2-port series adaptor + ideal voltage source
// An adaptor implementing a 2-port series connection and internal ideal voltage source between adaptors for Wave Digital Filter tree structures.
// This adaptor connects the two connected adaptors and an additional ideal voltage source in series
//
// #### Usage
//
// ```
// v1 = series_voltage(i, vin)
// buildtree( A : v1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `vin` :  voltage across the ideal current source in Volts
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// It should be used within the tree structure with one previous and one forward adaptor
// #### Reference
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.2
//----------------------------------------------------------
declare series_voltage author "Dirk Roosenburg";
declare series_voltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare series_voltage license "MIT-style STK-4.3 license";
series_voltage = 
case{
    (0, vin) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0 - R1^(p-1)*vin;  
    };
    (1, vin) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1 - R1^(p-1)*vin; 
    };
    (2, vin) => R0
    with{
        R0(R1) = R1; 
    };
};


//===============================Three Port Adaptors======================================
//========================================================================================


//----------------------`(wd.)parallel`--------------------------
// 3-port parallel adaptor
// An adaptor implementing a 3-port parallel connection between adaptors for Wave Digital Filter tree structures.
// This adaptor is used to connect adaptors simulating components connected in parallel in the circuit
//
// #### Usage
//
// ```
// buildtree( A : parallel : (B, C) );
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the tree structure with one previous and two forward adaptors
// #### Reference
// K. Werner Dissertation, 1.5.1
//----------------------------------------------------------
declare parallel author "Dirk Roosenburg";
declare parallel copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parallel license "MIT-style STK-4.3 license";
parallel= 
case{
    (0) => par_down
    with{
        par_down = si.bus(5) <: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 +  a1 * -R1/(R1 + R2) + a2 * R1/(R1 + R2);
        b2(R1, R2, a0, a1, a2) = a0 +  a1 * R2/(R1 + R2) + a2 * -R2/(R1 + R2);
    };
    (1) => par_up
    with{
        par_up = b0;
        b0(R1, R2, a1, a2) = a1 * R2/(R1 + R2) + a2 * R1/(R1 + R2);
    };
    (2) => R0
    with{
        R0(R1, R2) = 1/(1/R1+1/R2); 
    };

};


//----------------------`(wd.)series`--------------------------
// 3-port series adaptor
// An adaptor implementing a 3-port series connection between adaptors for Wave Digital Filter tree structures.
// This adaptor is used to connect adaptors simulating components connected in series in the circuit
//
// #### Usage
//
// ```
//
// tree =  A : (series : (B, C));
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the tree structure with one previous and two forward adaptors
// #### Reference
// K. Werner Dissertation, 1.5.2
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
series= 
case{

    (0) => ser_down
    with{
        ser_down = si.bus(5)<: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 * -R1/(R1+R2) + a1 * R2/(R1+R2) +  a2 *-R1/(R1+R2);
        b2(R1, R2, a0, a1, a2) = a0 * -R2/(R1+R2) + a1 * -R2/(R1+R2) + a2 * R1/(R1+R2);
    };
    (1) => ser_up
    with{
        ser_up = b0;
        b0(R1, R2, a1, a2) = -a1 - a2;
    };
    (2) => R0
    with{
        R0(R1, R2) = R1 + R2; 
    };
};



//constant declrations for library
p = 1; 
//some functions are declared in terms of p (rho) in advance of support of multiple kinds of waves within the system. 
//multiple waves are currently unsupported, only voltage waves are currently used

t = 1/ma.SR; //sampling rate reference for reactive elements


//===============================Structure Building Functions=============================
//========================================================================================


//----------------------`(wd.)builddown`--------------------------
// function for building the strucutre for calculating waves travling down the WDF tree structure
// It recursively steps through the given tree, parametrizes the adaptors, and builds an algorithm
// It is used in conjunction with the buildup() function to create a full structure
//
// #### Usage
//
// ```
// builddown(A : B)~buildup(A : B);
// ```
//
// Where: 
// * `(A : B)` : is a tree structure composed of WDF adaptors
//----------------------------------------------------------
declare builddown author "Dirk Roosenburg";
declare builddown copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare builddown license "MIT-style STK-4.3 license";
builddown(A : As) = ((upPortRes, addins(inputs(A(0)) - outputs(upPortRes))) :  A(0)) , addins(inputs(pardown(As)) - outputs(A(0))) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross(0, 0, 0, 0, 0, s_mtx(As))) : pardown(As)
with{

    //substitute for si.bus which can accept an argument of 0
    addins = 
    case{
        (0) => 0 : !; 
        (x) => si.bus(x);
    };
    
    //recursively build in parallel
    pardown = 
    case{
        ((Ax, Axx)) => builddown(Ax), pardown(Axx);
        (Ax) => builddown(Ax);
    };
    
    //generate a list of inputs from the next stage down the tree
    s_mtx = 
    case{
        ((Ax, Axx)) => inputs(builddown(Ax)), s_mtx(Axx);
        (Ax) => inputs(builddown(Ax));
    };

    //take the sum of the list
    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));

    upPortRes = parres(As);

    //generate a crossover matrix for the route object based on a list of i/o dimensions
    gencross = 
    case{
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        (0, 0, 0, 0, 0, 0) => 0 : !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (fcount, msum);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum, msum-count); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => ((count+out), out), gencross(out+1, next, count, fcount, msum, xs); //output is not a special output
    };
}; 

builddown(A) = A(0); 


//----------------------`(wd.)buildup`--------------------------
// function for building the strucutre for calculating waves travling up the WDF tree structure
// It recursively steps through the given tree, parametrizes the adaptors, and builds an algorithm
// It is used in conjunction with the builddown() function to create a full structure
//
// #### Usage
//
// ```
// builddown(A : B)~buildup(A : B);
// ```
//
// Where: 
// * `(A : B)` : is a tree structure composed of WDF adaptors
//----------------------------------------------------------
declare builddown author "Dirk Roosenburg";
declare builddown copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare builddown license "MIT-style STK-4.3 license";
buildup(A : As) = upPortRes, (parup(As) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross_up(0, 0, 0, 0, 0, s_mtx(As))) : split(s_mtx(As))) : A(1), addins(outputs(split(s_mtx(As))) + outputs(upPortRes) - inputs(A(1))) 
with{

    //substitute for si.bus which can accept an argument of 0
    addins = 
    case{
        (0) => 0 : !; 
        (x) => si.bus(x);
    };

    //recursively build in parallel
    parup =  //<: crossover(out_list(Ap)) : split(out_list(Ap))
    case{
        ((Ax, Axx)) => buildup(Ax), parup(Axx);
        (Ax) => buildup(Ax);
    };

    //generate a list of outputs from the next stage down the tree
    s_mtx = 
    case{
        ((Ax, Axx)) => outputs(buildup(Ax)), s_mtx(Axx);
        (Ax) => outputs(buildup(Ax));
    };
    
    //take the sum of a list
    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));

    //split based on a list of i/o dimensions
    split(inl) = (si.bus(n) <: si.bus(n), si.bus(n)), (addins(s-n))
    with{
        n = ba.count(inl);
        s = inl :> _; 
    };

    //generate a crossover matrix based for the route object based on a list of i/o dimensions
    gencross_up = 
    case{
        //corner case which must be coded manually
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        //user access function
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross_up(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        //more corner cases
        (0, 0, 0, 0, 0, 0) => 0: !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (msum, fcount);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum-count, msum); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => (out, (count+out)), gencross_up(out+1, next, count, fcount, msum, xs); //output is not a special output
    };

    upPortRes = parres(As);
};

buildup(A) = A(1);

//----------------------`(wd.)getres`--------------------------
// function for determining the upward-facing port resistance of a partial WDF tree structure
// It recursively steps through the given tree, parametrizes the adaptors, and builds and algorithm
// It is used by the buildup and builddown functions but is also helpful in testing
//
// #### Usage
//
// ```
// getres(A : B)~getres(A : B);
// ```
//
// Where: 
// * `(A : B)` : is a partial tree structure composed of WDF adaptors
//
// Note:
// This function cannot be used on a complete WDF tree. When called on an unadapted adaptor (u_ prefix), it will create errors
//----------------------------------------------------------
declare getres author "Dirk Roosenburg";
declare getres copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare getres license "MIT-style STK-4.3 license";
getres(A: As) = parres(As) : A(2);
getres(A) = A(2); 


//----------------------`(wd.)parres`--------------------------
// function for determining the upward-facing port resistance of a partial WDF tree structure
// It recursively steps through the given tree, parametrizes the adaptors, and builds and algorithm
// It is used by the buildup and builddown functions but is also helpful in testing
// this function is a parallelized version of getres
//
// #### Usage
//
// ```
// parres((A , B))~parres((A , B));
// ```
//
// Where: 
// * `(A , B)` : is a partial tree structure composed of WDF adaptors
//
// Note:
// This function cannot be used on a complete WDF tree. When called on an unadapted adaptor (u_ prefix), it will create errors
//----------------------------------------------------------
declare parres author "Dirk Roosenburg";
declare parres copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parres license "MIT-style STK-4.3 license";
parres((Ap1, Ap2)) = getres(Ap1) , parres(Ap2);
parres(Ap) = getres(Ap);


//----------------------`(wd.)buildout`--------------------------
// function for creating the output matrix for a WDF tree structure
// It recursively steps through the given tree and creates an output matrix passing only outputs
//
// #### Usage
//
// ```
// buildout( A : B );
// ```
//
// Where: 
// * `(A : B)` : is a tree structure composed of WDF adaptors
//
//----------------------------------------------------------
declare buildout author "Dirk Roosenburg";
declare buildout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare buildout license "MIT-style STK-4.3 license";
buildout(A: As) = parout(As)
with{
    parout((A, Ap)) = buildout(A), parout(Ap);
    parout(A) = buildout(A);
};
buildout(A) = outmtx(outputs(A(0)))
with{
    outmtx(1) = !; 
    outmtx(2) = !, _; 
};


//----------------------`(wd.)buildtree`--------------------------
// function for building the functioning DSP model from a WDF tree structure
// It recursively steps through the given tree, parametrizes the adaptors, and builds the algorithm
//
// #### Usage
//
// ```
// buildtree(A : B);
// ```
//
// Where: 
// * `(A : B)` : a tree structure composed of WDF adaptors
//----------------------------------------------------------
declare buildtree author "Dirk Roosenburg";
declare buildtree copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare buildtree license "MIT-style STK-4.3 license";
buildtree((A : B)) = builddown(A : B)~buildup(A : B) : buildout(A : B);




//TODO
//add input and output constructor. currently just performed manually. 
//this will likely include adding additional param options to adaptors. 
//add comments in faust formating


/*******************************************************************************
# Licenses

## STK 4.3 License

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

Any person wishing to distribute modifications to the Software is asked to send 
the modifications to the original developer so that they can be incorporated 
into the canonical version.  For software copyrighted by Dirk Roosenburg, 
email your modifications to <dirk.roosenburg.30@gmail.com>.  This is, however, not a 
binding provision of this license.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.

--------------------------------------------------------------------------------

## LGPL License

This program is free software; you can redistribute it and/or modify it under 
the terms of the GNU Lesser General Public License as published by the Free 
Software Foundation; either version 2.1 of the License, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along 
with the GNU C Library; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
*******************************************************************************/