//#################################### wavedigitalfilters.lib ####################################################################
// A library of basic adaptors and methods to help contstruct Wave Digital Filter models in Faust. Its official prefix is `wd`.
//################################################################################################################################

/************************************************************************
************************************************************************
FAUST library file

NOTE ABOUT LICENSES:
Each function in this library has its own license. Licenses are declared
before each function. Corresponding license terms can be found at the 
bottom of this file or in the Faust libraries documentation.

The Wave Digital Filter Library is organized into the following sections

*Simple One Port Adaptors
*Simple Two Port Adaptors
*Simple Three Port Adaptors
*One Port Non-Linear Adaptors
*Model-Building Functions

PLANNED ADDITIONS
*R-type Adaptors
*Multiport Non-Linear Adaptors


ABOUT THIS LIBRARY

This library is intended as a tool to help generating function DSP algorithims using Wave Digital Filters (WDF)
The library includes both port elements with which to build symbolic WDF trees and the tools to turn those trees into DSP algorithims

implementation examples can be found at https://github.com/droosenb/faust-wdf-library

a description of how adaptors are structured is shown at the head of *Simple One Port Adaptors

a description of how the library builds the DSP algorithim from the user-given tree is shown at the head of *Model-Building Functions

Many of the more in depth comments within the library include jargon. I plan to create videos detailing the theory of WDF's
For now I reccomend Kurt Werner's PhD, Virtual analog modeling of audio circuitry using wave digital filters, found here: 
https://searchworks.stanford.edu/view/11891203    
I have tried to maintain consistent syntax and notation to the thesis. 
This library currently includes the majority of the adaptors covered in chapter 1 and some from chapter 3. 

************************************************************************
************************************************************************/

ba = library("basics.lib");
ro = library("routes.lib");
ma = library("maths.lib");
si = library("signals.lib");

declare name "Faust Wave Digital Filter Library";
declare version "0.1";



//HOW ADAPTORS ARE STRUCTURED
/*
    In order for adaptors to be interpretable by the compiler, they must be structured in a specific way. 
    Each adaptor is divided into three cases by their first parameter. This paramter, while accessible by the user, should only be set by the compiler/builder.
    All other parameters are value declarations (for components), inputs (for voltage or current ins), or parameter controls (for potentiometers/varible capicitors/varible inductors)
    
    --- first case ---
    (0, params) => downwardgoing(R1, ... Rn, a0, a1, ... an) -- function calculating downward going waves (b1, b2, ... bn)
        this function takes any number of port resistances, the downward going wave, and any number of upward going waves as inputs. 
        These values/waves are used to calculate the downward going waves coming from this adaptor

    --- second case ---
    (1, params) =>  upwardgoing(R1, ... Rn, a1, ... an) -- funciton calculating upward going wave (b0)
        this funciton takes any number of port resistances and any number of upward going waves as inputs
        these values/waves are used to calculate the upward going wave coming from this adaptor

    --- third case --- 
    (2, params) => portresistance(R1, ... Rn) -- function calculating adaptor's port resitance (R0)
        this function takes any number of port resistances as inputs
        these values are used to calculate the upward going port resistance of the element


    --Unadapted Adaptors--
    Unadapted adaptor's names will always begin "u_"
    An unadapted adaptor MUST be used as the root of the WDF tree structure.
    Unadapted adaptors can ONLY be used as a root of the WDF tree structure. 
    While unadapted adaptors contain all three cases, the second and thrid are purely structural. 
    Only the first case should contain computational information. 

*/

//=============================One Port Adaptors==========================================
//========================================================================================

//NOTES
//one 

//----------------------`(wd.)resistor`--------------------------
// Resistor
// A basic adaptor implementing a resistor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
//
// #### Usage
//
// ```
// r1(i) = resistor(i, R);
// tree = A : r1;
//
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedence of the resistor being modeled in Ohms. 
//
// Note:
// 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
resistor = 
case{
    (0, R) => !, 0; //a0 in, b0 out
    (1, R) => _; //b0 passthru
    (2, R) => R0 //port resistance. may replace this with dynamic allocation for port resistances. 
    with{
        R0 = R; 
    };
};


//----------------------`(wd.)resistor_output`--------------------------
// Resistor + voltage Out
// A basic adaptor implementing a resistor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// The resistor will also pass the voltage across itself as an output of the model
//
// #### Usage
//
// ```
// rout(i) = resistor_output(i, R);
// tree = A : rout;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedence of the resistor being modeled in Ohms. 
//
// Note: 
//
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
resistor_output = 
case{
    (0, R) => 0, _*.5; //a0 in, b0 out
    (1, R) => _, !; //b0 passthru
    (2, R) => R0 //port resistance. may replace this with dynamic allocation for port resistances. 
    with{
        R0 = R; 
    };
};


//----------------------`(wd.)capacitor`--------------------------
// Capacitor
// A basic adaptor implementing a capacitor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// This capacitor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// c1(i) = capacitor(i, R);
// tree = A : c1;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Capacitance/Impedence of the capacitor being modeled in Farads. 
//
// Note:
// 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
capacitor =
case{
    (0, R) => _*1; 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
};

//----------------------`(wd.)capacitor_output`--------------------------
// Capacitor + voltage out
// A basic adaptor implementing a capacitor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// The capacitor will also pass the voltage across itself as an output of the model
// This capacitor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// cout(i) = capacitor_output(i, R);
// tree = A : cout;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Capacitance/Impedence of the capacitor being modeled in Farads. 
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
capacitor_output = 
case{
    (0, R) => b0
    with{
        b0(a1) =  a1*1, a1*.5 + (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
};

//----------------------`(wd.)inductor`--------------------------
// Inductor
// A basic adaptor implementing an inductor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// This inductor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// l1(i) = inductor(i, R);
// tree = A : l1;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Inductance/Impedence of the inductor being modeled in Henries. 
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
inductor =
case{
    (0, R) => _*(-1); 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
};

//----------------------`(wd.)inductor_output`--------------------------
// Inductor + Voltage out
// A basic adaptor implementing an inductor for use within Wave Digital Filter tree structures
//
// It should be used as a leaf/terminating element of the tree structure
// The inductor will also pass the voltage across itself as an output of the model
// This inductor model was digitized using the bi-linear transform
//
// #### Usage
//
// ```
// lout(i) = inductor_output(i, R);
// tree = A : lout;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Inductance/Impedence of the inductor being modeled in Henries.
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
inductor_output = 
case{
    (0, R) => b0
    with{
        b0(a1) = a1*(-1), a1*.5 - (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
};

//----------------------`(wd.)resVoltage`--------------------------
// Resistive Voltage Source
// An adaptor implementing a resitive voltage source within Wave Digital Filter tree structures.
//
// It should be used as a leaf/terminating element of the tree structure
// It is comprised of an ideal voltage source in series with a resistor
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = resVoltage(i, R, ein);
// tree = A : v1;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `ein` : Voltage/Potential of the ideal voltage source in Volts
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
resVoltage = 
case{
    (0, R, ein) => R^(1-p)*ein;
    (1, R, ein) => _; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}; 

//----------------------`(wd.)resVoltage_output`--------------------------
// Resistive Voltage Source + voltage output
// An adaptor implementing a resitive voltage source within Wave Digital Filter tree structures.
//
// It should be used as a leaf/terminating element of the tree structure
// It is comprised of an ideal voltage source in series with a resistor
// Can be used for either DC (constant) or AC (signal) voltage sources.
// The resistive voltage source will also pass the voltage across it as an output of the model
//
// #### Usage
//
// ```
// vout(i) = resVoltage_output(i, R, ein);
// tree = A : vout;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
resVoltage_output = 
case{
    (0, R, ein) => R^(1-p)*ein, _*.5 + R^(1-p)*ein*.5 ;
    (1, R, ein) => _, !; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}; 

//----------------------`(wd.)u_resVoltage`--------------------------
// Resistive Voltage Source (Unadapted)
// An unadapted adaptor implementing a resitive voltage source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// It is comprised of an ideal voltage source in series with a resistor
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = u_resVoltage(i, R, ein);
// tree =  v1 : B;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
u_resVoltage =
case {
    (0, R, ein) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R+R0) + ein*(2*R0^p)/(R + R0);
    };
    (1, R, ein) => !, !; 
    (2, R, ein) => 0; 

};


//----------------------`(wd.)resCurrent`--------------------------
// Resistive Current Source
// An adaptor implementing a resitive current source within Wave Digital Filter tree structures.
//
// It should be used as a leaf/terminating element of the tree structure
// It is comprised of an ideal current source in parallel with a resistor
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = resCurrent(i, R, jin);
// tree = A : i1;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the parallel resistor in Ohms
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
resCurrent =
case {
    (0, R, jin) => 2*R^(p)*jin;
    (1, R, jin) => _; 
    (2, R, jin) => R0
    with {
        R0 = R; 
    };
}; 

//----------------------`(wd.)u_resCurrent`--------------------------
// Resistive Current Source (Uadapted)
// An unadapted adaptor implementing a resitive current source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// It is comprised of an ideal current source in parallel with a resistor
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = u_resCurrent(i, R, jin);
// tree =  i1 : B;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Reistance/Impedence of the series resistor in Ohms
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
u_resCurrent =
case {
    (0, R, jin) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R + R0) + jin*(2*R*R0^p)/(R + R0);
    };
    (1, R, jin) => !, !; 
    (2, R, jin) => 0; 

};

//----------------------`(wd.)u_voltage`--------------------------
// Ideal Voltage Source (Unadapted)
// An adaptor implementing an ideal voltage source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = u_Voltage(i, ein);
// tree =  v1 : B;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
u_v                                                              voltage = 
case{
    (0 , ein) => b0
    with{
        b0(R0, a0) = 2*R0^(p-1)*ein -a0;
    };
    (1, ein) => !, !; 
    (2, ein) => 0; 
};


//----------------------`(wd.)u_current`--------------------------
// Resistive Current Source (Unadapted)
// An unadapted adaptor implementing an ideal current source within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = u_current(i, jin);
// tree =  i1 : B;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
u_current = 
case{
    (0 , jin) => b0
    with{
        b0(R0, a0) = 2*R0^(p)*jin + a0;
    };
    (1, jin) => !, !; 
    (2, jin) => 0; 
};

//switch. 
//lambda = -1 for closed switch, lambda = 1 for open switch



//----------------------`(wd.)u_switch`--------------------------
// Ideal Switch (Unadapted)
// An unadapted adaptor implementing an ideal switch for Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
//
// #### Usage
//
// ```
// s1(i) = u_resCurrent(i, lambda);
// tree =  s1 : B;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `lambda` : switch state control. -1 for closed switch, 1 for open switch.
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
u_Switch = 
case {
    (0, lambda) => b0
    with{
        b0(R0, a0) = a0*lambda; 
    };
    (1, lambda) => !, !; 
    (2, lambda) => 0; 
};


//=============================Two Port Adaptors==========================================
//========================================================================================


//----------------------`(wd.)u_parallel_2`--------------------------
// 2-port parallel adaptor (Unadapted)
// An unadapted adaptor implementing a 2-port parallel connection between adaptors for Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// This adaptor is used to connect adaptors simulating components connected in parallel in the circuit
//
// #### Usage
//
// ```
//
// tree =  u_parallel_2 : (A, B);
// ```
//
//
// Note: 
// Only usable as the root of a tree
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
u_parallel_2 = 
case{
    (0) => u_par
    with{ 
        u_par = si.bus(4) <: b1, b2;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) + a1*(2*R0^p*R1^(1-p)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) + a0*(2*R0^(1-p)*R1^p))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
};


//----------------------`(wd.)parallel_2`--------------------------
// 2-port parallel adaptor
// An adaptor implementing a 2-port parallel connection between adaptors for Wave Digital Filter tree structures.
//
// It should be used within the tree structure with one previous and one forward adaptor
// This adaptor is used to connect adaptors simulating components connected in parallel in the circuit
//
// #### Usage
//
// ```
//
// tree =  A : (parallel_2 : B);
// ```
//
//
// Note: 
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
parallel_2 = 
case{
    (0) => par_down
    with{
        par_down = b1; 
        b1(R1, a0, a1) = a0;  
    };
    (1) => par_up
    with{
        par_up = b0; 
        b0(R1, a1) = a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};

//----------------------`(wd.)u_series_2`--------------------------
// 2-port series adaptor (Unadapted)
// An unadapted adaptor implementing a 2-port series connection between adaptors for Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
// This adaptor is used to connect adaptors simulating components connected in series in the circuit
//
// #### Usage
//
// ```
//
// tree =  u_series_2 : (A, B);
// ```
//
//
// Note: 
// Only usable as the root of a tree
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
u_series_2 = 
case{
    (0) => u_ser
    with{ 
        u_ser = si.bus(4) <: b1, b2;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) - a1*(2*R0^p*R1^(1-p)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) - a0*(2*R0^(1-p)*R1^p))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
};


//----------------------`(wd.)series_2`--------------------------
// 2-port series adaptor
// An adaptor implementing a 2-port series connection between adaptors for Wave Digital Filter tree structures.
//
// It should be used within the tree structure with one previous and one forward adaptor
// This adaptor is used to connect adaptors simulating components connected in series in the circuit
//
// #### Usage
//
// ```
//
// tree =  A : (series_2 : B);
// ```
//
//
// Note: 
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
series_2 = 
case{
    (0) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0;  
    };
    (1) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};

//----------------------`(wd.)parallel_current`--------------------------
// 2-port parallel adaptor + ideal current source
// An adaptor implementing a 2-port series connection and internal idealized current source between adaptors for Wave Digital Filter tree structures.
//
// It should be used within a tree structure with one previous and one forward adaptor
// This adaptor connects the two connected adaptors and an additional ideal current source in parallel
//
// #### Usage
//
// ```
// i1 = parallel_current(i, jin);
// tree =  A : (i1 : B);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `jin` :  Current through the ideal current source in Amps
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//
// #### Reference
// Werner Dissertation, 1.4.2
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
parallel_current = 
case{
    (0, jin) => par_current_down
    with{
        par_current_down = b1; 
        b1(R1, a0, a1) = a0 + R1^p*jin;  
    };
    (1, jin) => par_current_up
    with{
        par_current_up = b0; 
        b0(R1, a1) = a1 + R1^p*jin; 
    };
    (2, jin) => R0
    with{
        R0(R1) = R1; 
    };
};


//----------------------`(wd.)series_voltage`--------------------------
// 2-port series adaptor + ideal voltage source
// An adaptor implementing a 2-port series connection and internal ideal voltage source between adaptors for Wave Digital Filter tree structures.
//
// It should be used within the tree structure with one previous and one forward adaptor
// This adaptor connects the two connected adaptors and an additional ideal voltage source in series
//
// #### Usage
//
// ```
// v1 = series_voltage(i, vin)
// tree =  A : (v1 : B);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `vin` :  voltage across the ideal current source in Volts
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//
// #### Reference
// Werner Dissertation, 1.4.2
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
series_voltage = 
case{
    (0, vin) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0 - R1^(p-1)*vin;  
    };
    (1, vin) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1 - R1^(p-1)*vin; 
    };
    (2, vin) => R0
    with{
        R0(R1) = R1; 
    };
};


//===============================Three Port Adaptors======================================
//========================================================================================


//----------------------`(wd.)parallel`--------------------------
// 3-port parallel adaptor
// An adaptor implementing a 3-port parallel connection between adaptors for Wave Digital Filter tree structures.
//
// It should be used within the tree structure with one previous and two forward adaptors
// This adaptor is used to connect adaptors simulating components connected in parallel in the circuit
//
// #### Usage
//
// ```
//
// tree =  A : (parallel : (B, C));
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//
// #### Reference
// K. Werner Dissertation, 1.5.1
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
parallel= 
case{
    (0) => par_down
    with{
        par_down = si.bus(5) <: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 +  a1 * -R1/(R1 + R2) + a2 * R1/(R1 + R2);
        b2(R1, R2, a0, a1, a2) = a0 +  a1 * R2/(R1 + R2) + a2 * -R2/(R1 + R2);
    };
    (1) => par_up
    with{
        par_up = b0;
        b0(R1, R2, a1, a2) = a1 * R2/(R1 + R2) + a2 * R1/(R1 + R2);
    };
    (2) => R0
    with{
        R0(R1, R2) = 1/(1/R1+1/R2); 
    };

};


//----------------------`(wd.)series`--------------------------
// 3-port series adaptor
// An adaptor implementing a 3-port series connection between adaptors for Wave Digital Filter tree structures.
//
// It should be used within the tree structure with one previous and two forward adaptors
// This adaptor is used to connect adaptors simulating components connected in series in the circuit
//
// #### Usage
//
// ```
//
// tree =  A : (series : (B, C));
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//
// #### Reference
// K. Werner Dissertation, 1.5.2
//----------------------------------------------------------
declare zero author "Dirk Roosenburg";
declare zero copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare zero license "MIT-style STK-4.3 license";
series= 
case{

    (0) => ser_down
    with{
        ser_down = si.bus(5)<: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 * -R1/(R1+R2) + a1 * R2/(R1+R2) +  a2 *-R1/(R1+R2);
        b2(R1, R2, a0, a1, a2) = a0 * -R2/(R1+R2) + a1 * -R2/(R1+R2) + a2 * R1/(R1+R2);
    };
    (1) => ser_up
    with{
        ser_up = b0;
        b0(R1, R2, a1, a2) = -a1 - a2;
    };
    (2) => R0
    with{
        R0(R1, R2) = R1 + R2; 
    };
};

//===============================One Port Non-linear Adaptors=============================
//========================================================================================

//----------------------`(wd.)u_idealDiode`--------------------------
// Ideal Diode (Unadapted)
// An unadapted adaptor implementing an ideal diode for Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
//
// #### Usage
//
// ```
// 
// tree =  u_idealDiode : B;
// ```
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
//
// #### Reference
// K. Werner Dissertation, 3.2.2
//----------------------------------------------------------
declare u_idealDiode author "Dirk Roosenburg";
declare u_idealDiode copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_idealDiode license "MIT-style STK-4.3 license";
u_idealDiode =
case{
    (0) => b1
    with{
        b1(R1, a0) = a0 : abs : *(-1);
    };
    (1) => !, !; 
    (2) => 0; 
};

//----------------------`(wd.)u_chua`--------------------------
// Chua Diode (Unadapted)
// An adaptor implementing the chua diode / non-linear resistor within Wave Digital Filter tree structures.
//
// It should be used as the root/top element of the tree structure
//
// #### Usage
//
// ```
// chua1(i) = u_chua(i, G1, G2, V0);
// tree =  chua1 : B;
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `G1` : resistance parameter 1 of the chua diode
// * `G2` : resistance parameter 2 of the chua diode
// * `V0` : voltage parameter of the chua diode
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a seperate function before integration into the tree structure.
// Correct implementation is shown above.
//
// #### Reference
// Meerkotter and Scholz, "Digital Simulation of Nonlinear Circuits by Wave Digital Filter Principles"
//----------------------------------------------------------
declare u_chua author "Dirk Roosenburg";
declare u_chua copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_chua license "MIT-style STK-4.3 license";
u_chua = 
case{
    (0, G1, G2, V0) => b1
    with{
        b1(R1, a0) = g_1*a0 + 1/2*(g_2 - g_1)*(((a0 + a_0) : abs) - ((a0 - a_0): abs))
        with{
            g_1 = (1-G1*R1)/(1+G1*R1);
            g_2 = (1-G2*R1)/(1+G2*R1);
            a_0 = V0*(1+G2*R1);
        };
    };
    (1, G1, G2, V0) => !, !; 
    (2, G1, G2, V0) => 0; 
};


//simple diode pair as outlined in Werner
//params: Is = saturation current, Vt = thermal voltage
u_diode_pair = 
case{
    (0, Is, Vt) => b1
    with{
        b1(R1, a1) = a1 + 2*R1*Is - 2*Vt*lambert(R1*Is/Vt*(((a1+R1*Is)/Vt) : exp));
    };
    (1, Is, Vt) => !, !; 
    (2, Is, Vt) => 0; 
};

//lambert function for use in diode calculation
//adapted from  KM brigg's c++ function
lambert(z) = ba.if((z<(-em1+.0001)), less_approx, greater_approx)
with{
    less_approx = -1.0
     +2.331643981597124203363536062168*r
     -1.812187885639363490240191647568*q
     +1.936631114492359755363277457668*r*q
     //-2.353551201881614516821543561516*q2
    with{
        q = z+em1;
        r = sqrt(q);
        //q2 = q*q; 
    };
    eps=4.0e-16; 
    em1=0.3678794411714423215955237701614608;
    greater_approx = z : init : seq(i, 5, approx)
    with{
        init(w) = ba.if((z<1), init1, init2)
        with{
            init1 = -1.0+p*(1.0+p*(-0.333333333333333333333+p*0.152777777777777777777777))
            with{
                p=sqrt(2.0*(2.7182818284590452353602874713526625*z+1.0));
            };
            init2 = log(abs(z));
        };
        approx(w) = w-t
        with{
            e=exp(w);
            t=(w*e-z)/(e*p-.5*(p+1.0)*(w*e-z)/p);
            p=w+1; 
        };
    };
};

//single diode as outlined in Werner
u_diode_single = 
case{
    (0, Is, Vt) => b1
    with{
        b1(R1, a1) = ma.signum(a1)*( (a1 : abs) + 2*R1*Is - 2*Vt*(lambert(R1*Is/Vt*((((a1 : abs)+R1*Is)/Vt) : exp)) + lambert(-R1*Is/Vt*(((-1*(a1 : abs)+R1*Is)/Vt) : exp))));
    };
    (1, Is, Vt) => !, !; 
    (2, Is, Vt) => 0; 
};

u_diode_antiparallel =
case{
    (0, Is, Vt, M, N) => b1
    with{
        b1(R1, a1) = a1 - 2*lam*Vt*(mu0* lambert((R1*Is)/(mu0*Vt) * exp((lam*a1)/(mu0*Vt))) + 
                                    mu1* lambert((-R1*Is)/(mu1*Vt) * exp((-lam*a1)/(mu1*Vt))))
        with{
            lam = ma.signum(a1); 
            mu0 = ba.if((a1 < 0), N, M);
            mu1 = ba.if((a1 > 0), M, N);
        };
    };
    (1, Is, Vt, M, N) => !, !; 
    (2, Is, Vt, M, N) => 0; 
};

//constant declrations for library. don't alter these (for now)
p = 1; //declare voltage waves. 
t = 1/ma.SR; //sampling rate reference for reactive elements


//constructor private functions

//substitute for si.bus which can accept an argument of 0
addins = 
case{
    (0) => 0 : !; 
    (x) => si.bus(x);
};

//downtree constructor 
builddown(A : As) = ((upPortRes, addins(inputs(A(0)) - outputs(upPortRes))) :  A(0)) , addins(inputs(pardown(As)) - outputs(A(0))) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross(0, 0, 0, 0, 0, s_mtx(As))) : pardown(As)
with{
    
    pardown = 
    case{
        ((Ax, Axx)) => builddown(Ax), pardown(Axx);
        (Ax) => builddown(Ax);
    };
    
    s_mtx = 
    case{
        ((Ax, Axx)) => inputs(builddown(Ax)), s_mtx(Axx);
        (Ax) => inputs(builddown(Ax));
    };

    upPortRes = parres(As);

    gencross = 
    case{
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        (0, 0, 0, 0, 0, 0) => 0 : !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (fcount, msum);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum, msum-count); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => ((count+out), out), gencross(out+1, next, count, fcount, msum, xs); //output is not a special output

    };

    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));
}; 

builddown(A) = A(0); 

//uptree constructor
buildup(A : As) = upPortRes, (parup(As) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross_up(0, 0, 0, 0, 0, s_mtx(As))) : split(s_mtx(As))) : A(1), addins(outputs(split(s_mtx(As))) + outputs(upPortRes) - inputs(A(1))) 
with{

    parup =  //<: crossover(out_list(Ap)) : split(out_list(Ap))
    case{
        ((Ax, Axx)) => buildup(Ax), parup(Axx);
        (Ax) => buildup(Ax);
    };

    //create our dimension matrix
    s_mtx = 
    case{
        ((Ax, Axx)) => outputs(buildup(Ax)), s_mtx(Axx);
        (Ax) => outputs(buildup(Ax));
    };
    
    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));
    //split signals based on a dimension matrix
    split(inl) = (si.bus(n) <: si.bus(n), si.bus(n)), (addins(s-n))
    with{
        n = ba.count(inl);
        s = inl :> _; 
    };

    gencross_up = 
    case{
        //corner case which must be coded manually
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        //user access function
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross_up(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        //more corner cases
        (0, 0, 0, 0, 0, 0) => 0: !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (msum, fcount);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum-count, msum); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => (out, (count+out)), gencross_up(out+1, next, count, fcount, msum, xs); //output is not a special output

    };
    //crossover.  feed a matrix with the dimensions of the buss. 
    crossover(inl) =  par(i, ba.count(inl), ba.selector((ba.subseq(inl, 0, i):> _)*ma.signum(i), (inl:> _))), par(i, ba.count(inl), (!, addins(ba.take(i+1, inl) - 1)));

    upPortRes = parres(As);
};

buildup(A) = A(1);

//resistance contructor. 
//maybe change this to a dynamic programming method as current method involves calculating port resistance for each element many times. 
getres(A: As) = parres(As) : A(2);
getres(A) = A(2); 

parres((Ap1, Ap2)) = getres(Ap1) , parres(Ap2);
parres(Ap) = getres(Ap);


//TODO
//add input and output constructor. currently just performed manually. 
//this will likely include adding additional param options to adaptors. 
//add comments in faust formating


/*******************************************************************************
# Licenses

## STK 4.3 License

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

Any person wishing to distribute modifications to the Software is asked to send 
the modifications to the original developer so that they can be incorporated 
into the canonical version.  For software copyrighted by Julius O. Smith III, 
email your modifications to <jos@ccrma.stanford.edu>.  This is, however, not a 
binding provision of this license.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.

--------------------------------------------------------------------------------

## LGPL License

This program is free software; you can redistribute it and/or modify it under 
the terms of the GNU Lesser General Public License as published by the Free 
Software Foundation; either version 2.1 of the License, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along 
with the GNU C Library; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
*******************************************************************************/